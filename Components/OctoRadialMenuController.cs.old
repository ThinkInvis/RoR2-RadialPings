using RoR2;
using RoR2.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace ThinkInvisible.RadialPings {
	[RequireComponent(typeof(MPEventSystemLocator))]
	public class OctoRadialMenuController : MonoBehaviour {
		const float deadZoneOuter = 0.9f;
		const float deadZoneOuterSqr = deadZoneOuter*deadZoneOuter;
		const float deadZoneInner = 0.4f;
		const float deadZoneInnerSqr = deadZoneInner*deadZoneInner;

		const float sliceSize = (Mathf.PI * 2f)/8f;
		const float halfSliceSize = sliceSize/2f;

		const float hoverAlphaMin = 0.5f;
		const float hoverAlphaMax = 0.8f;
		const float hoverSizeBoost = 0.1f;
		const float unhoverDecayRate = 1f;
		const float defaultMaxHoverTime = 0.1f;

		const float totalDisposeTime = 0.25f;

		const float pingTime = 0.5f;
		float pingStopwatch = 0f;

		public float introAnimSpeed = 1f;

		float totalScale = 0f;
		public float targetScaleScreenFraction = 0.75f;
		float scaleVel = 0f;
		float disposeTimer = -1f;
		
		int currentSegment = -1;

		float[] hoverTimes = new float[8];
		public float[] maxHoverTimes = new float[8];

		public Camera targetCam = null;

		RectTransform myRect;
		Transform[] myButtons = new Transform[8];

		public string[] captionTokens = new string[8];
		public delegate string RetrieveSubcaption(OctoRadialMenuController sender);
		public RetrieveSubcaption[] subcaptionContexts = new RetrieveSubcaption[8];
		public RetrieveSubcaption defaultSubcaptionContext;

		public PlayerCharacterMasterController targetPcmc;

		TextMeshPro myText;
		TextMeshPro mySubText;

		public PingerController.PingInfo previewPingInfo;

		bool ReferencesSetup = false;
		public void SetupReferences() {
			if(ReferencesSetup) return;
			ReferencesSetup = true;
			myRect = GetComponent<RectTransform>();
			for(int i = 0; i < 8; i++) {
				myButtons[i] = transform.Find($"Button{i+1}");
			}
			myText = transform.Find("Caption").gameObject.GetComponent<TextMeshPro>();
			mySubText = transform.Find("Subcaption").gameObject.GetComponent<TextMeshPro>();
		}

		void Awake() {
			SetupReferences();
		}
		
		void Update() {
			totalScale = Mathf.SmoothDamp(totalScale, targetScaleScreenFraction, ref scaleVel, introAnimSpeed, 100f, Time.deltaTime);

			UpdateDisplay();

			UpdatePingPreview();

			if(disposeTimer < 0f) UpdateCursor();
			else {
				disposeTimer -= Time.deltaTime;
				if(disposeTimer <= 0f)
					GameObject.Destroy(this.gameObject);
			}
		}

		void UpdatePingPreview() {
			pingStopwatch += Time.deltaTime;
			if(pingStopwatch > pingTime) {
				pingStopwatch = 0f;
				PingerController.GeneratePingInfo(new Ray(targetPcmc.bodyInputs.aimOrigin, targetPcmc.bodyInputs.aimDirection), targetPcmc.body.gameObject, out previewPingInfo);
			}
		}

		void UpdateDisplay() {
			myRect.localScale = new Vector3(totalScale, totalScale, 1f);
			for(int i = 0; i < 8; i++) {
				var hoverTimeFrac = hoverTimes[i]/(maxHoverTimes[i]>0?maxHoverTimes[i]:defaultMaxHoverTime);
				var scaleTotal = 1f + hoverTimeFrac * hoverSizeBoost;
				myButtons[i].localScale = new Vector3(scaleTotal, scaleTotal, 1f);
				var alphaTotal = Mathf.Lerp(hoverAlphaMin, hoverAlphaMax, hoverTimeFrac);
				if(disposeTimer > 0f)
					alphaTotal *= disposeTimer/totalDisposeTime;
				var alphaColor = new Color(1f, 1f, 1f, alphaTotal);
				myButtons[i].gameObject.GetComponent<Image>().color = alphaColor;
				myButtons[i].Find("Icon").gameObject.GetComponent<Image>().color = alphaColor;
			}
			
			mySubText.text = "";
			if(currentSegment == -2) {
				myText.text = Language.GetString("RADIALPINGS_CANCEL");
			} else if(currentSegment == -1) {
				myText.text = Language.GetString("RADIALPINGS_QUICK");
				if(defaultSubcaptionContext != null) mySubText.text = defaultSubcaptionContext.Invoke(this);
			} else {
				myText.text = Language.GetString(captionTokens[currentSegment]);
				if(subcaptionContexts[currentSegment] != null) mySubText.text = subcaptionContexts[currentSegment].Invoke(this);
			}
		}

		void UpdateCursor() {
			RectTransformUtility.ScreenPointToLocalPointInRectangle(myRect, Input.mousePosition, targetCam, out Vector2 cursorPosNorm);
			
			cursorPosNorm = Rect.PointToNormalized(myRect.rect, cursorPosNorm);
			
			float cursorTheta = Mathf.Atan2(cursorPosNorm.y-0.5f, cursorPosNorm.x-0.5f);
			if(cursorTheta < 0) cursorTheta += Mathf.PI * 2f;
			float cursorDistNormSqr = ((cursorPosNorm - new Vector2(0.5f, 0.5f))*2f).sqrMagnitude;
			
			float cursorThetaWrap = cursorTheta - Mathf.PI * 2;

			bool cInRange = cursorDistNormSqr < deadZoneOuterSqr && cursorDistNormSqr > deadZoneInnerSqr;

			currentSegment = cursorDistNormSqr > deadZoneOuterSqr ? -2 : -1;

			for(int i = 0; i < 8; i++) {
				if(!cInRange) {
					hoverTimes[i] = Mathf.Max(0f, hoverTimes[i] - Time.deltaTime * unhoverDecayRate);
					continue;
				}
				float targetThetaMin = i * sliceSize - halfSliceSize;
				float targetThetaMax = targetThetaMin + sliceSize;
				if(((cursorTheta > targetThetaMin && cursorTheta < targetThetaMax) || (cursorThetaWrap > targetThetaMin && cursorThetaWrap < targetThetaMax))
					&& cursorDistNormSqr > deadZoneInnerSqr && cursorDistNormSqr < deadZoneOuterSqr) {
					currentSegment = i;
					hoverTimes[i] = Mathf.Min(hoverTimes[i]+Time.deltaTime, maxHoverTimes[i] > 0f ? maxHoverTimes[i] : defaultMaxHoverTime);
					if(maxHoverTimes[i] > 0f && hoverTimes[i] > maxHoverTimes[i]) {
						Activate(targetPcmc);
						break;
					}
				} else hoverTimes[i] = Mathf.Max(0f, hoverTimes[i] - Time.deltaTime * unhoverDecayRate);
			}
		}

		public void Activate(PlayerCharacterMasterController sender, float fadeDistanceTo = 1.5f) {
			if(disposeTimer >= 0f) return;
			disposeTimer = totalDisposeTime;
			targetScaleScreenFraction = fadeDistanceTo;
			GetComponent<CursorOpener>().enabled = false;
			onActivate?.Invoke(sender, currentSegment);
		}

		public void SilentActivate(float fadeDistanceTo = 1.5f) {
			if(disposeTimer >= 0f) return;
			disposeTimer = totalDisposeTime;
			GetComponent<CursorOpener>().enabled = false;
			targetScaleScreenFraction = fadeDistanceTo;
		}

		public void AssignIconSprite(int slot, Sprite sprite) {
			myButtons[slot].Find("Icon").gameObject.GetComponent<Image>().sprite = sprite;
		}
		public void AssignIconSprite(int slot, Sprite sprite, Color color) {
			AssignIconSprite(slot, sprite);
			myButtons[slot].Find("Icon").gameObject.GetComponent<Image>().color = color;
		}

		public delegate void OnActivate(PlayerCharacterMasterController sender, int index);
		public event OnActivate onActivate;
	}
}